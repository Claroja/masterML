<html>
<style>
.axis path,
.axis line{
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}
.axis text {
    font-family: sans-serif;
    font-size: 11px;
}

svg {
	display:inline-block;
}
</style>
    <body>
	<svg id=zero width=300 height =300 ></svg>
	<table>
  <tr>
    <th>x</th>
    <th>y</th>
    <th>△y</th>
    <th>g</th>
  </tr>
</table>
	
	<script src="https://cdn.bootcss.com/d3/3.5.17/d3.min.js"></script>
	<script src="../share/axis.js"></script>
	<script>
		
		k=4;
		b=0;
		x=[0,10];
		y=x.map(x=>k*x+b);  //做投影的直线
		
		x0=[4,2]
		y0=[4,4]  //原点
		p=d3.zip(x0,y0)
		x1=p.map(p=>(k*(p[1]-b)+p[0])/(k*k+1));
		y1=x1.map(x=>k*x+b);  //投影点
		z=d3.zip(x0,y0,x1,y1)
		svg = d3.select("svg[id=zero]")  //损失函数坐标系
		temp= axix(svg,[-1,11],[-1,11])
		xs = temp[0]
		ys =temp[1]		
		
		svg.append('line')  //添加投影的线
			.attr('x1',xs(x[0]))
			.attr('y1',ys(y[0]))
			.attr('x2',xs(x[1]))
			.attr('y2',ys(y[1]))
			.attr('stroke','black')

		svg.selectAll('circle[class=m]')  //添加投影点
			.data(z)
			.enter()
			.append('circle')
			.attr('cx',(d)=>xs(d[2]))
			.attr('cy',(d)=>ys(d[3]))
			.attr('r',2)
			.attr('stroke','black')
			.attr('class','m')
			
		svg.selectAll('circle[class=p]')  //添加屏p点
			.data(z)
			.enter()
			.append('circle')  //这里标签的属性只能在attr方法里添加，不能像selectAll一样用css选择器
			.attr('cx',(d)=>xs(d[0]))
			.attr('cy',(d)=>ys(d[1]))
			.attr('r',2)
			.attr('stroke','black')
			.attr('class','p')
			
// 		svg.append('line')	//	添加点和投影点的连线
// 			.attr('x1',xs(p[0]))
// 			.attr('y1',ys(p[1]))
// 			.attr('x2',xs(x1))
// 			.attr('y2',ys(y1))
// 			.attr('stroke','black')

// 		data = d3.zip(x,y)
// 		

// 
// 		var lineGen = d3.svg.line()
// 		  .x(function(d) {
// 		    return xlinear(d[0]);
// 		  })
// 		  .y(function(d) {
// 		    return ylinear(d[1]);
// 		  });
// 		  
// 		  
// 		svg.append('svg:path')
// 		  .attr('d', lineGen(data))
// 		  .attr('stroke', 'green')
// 		  .attr('stroke-width', 2)
// 		  .attr('fill', 'none');				
// 		
// 			function iter(x,alpha)
// 			{
// 				g_list=[];
// 				x_list=[];
// 				y_list=[];
// 				x__list=[];
// 				for(i=1;i<1000;i++){
// 					y=x*x;
// 					x_=2*x;
// 					gradient = alpha*x_;
// 					x_list.push(x);
// 					y_list.push(y);
// 					x__list.push(x_);
// 					g_list.push(gradient)
// 					x=x-gradient;
// 					y=x*x;
// 				}
// 				return d3.zip(x_list,y_list,x__list,g_list)
// 			}
// 			
//   //点击 观察拟合直线和损失函数的关系
// 		testdata =  iter(x=100,alpha=0.5);
// 		console.log(testdata);
// 		svg.on("mousedown",function(){
// 			data = testdata.shift();
// 			console.log(data);
// 			svg.append('circle')
// 			.attr('cx',xlinear(data[0]))
// 			.attr('cy',ylinear(data[1]))
// 			.attr('r',2);	
// 		tab.append("tr")
// 			.selectAll("td")
// 			.data(data)
// 			.enter()
// 			.append("td")
// 			.text((d)=>d.toFixed(2))
// 			})	
        </script>
    </body>
</html>